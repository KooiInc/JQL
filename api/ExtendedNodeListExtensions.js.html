<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>ExtendedNodeListExtensions.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Helpers.html">Helpers</a><ul class='methods'><li data-type='method'><a href="module-Helpers.html#~time">time</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="CollectionLambdas.html">CollectionLambdas</a><ul class='methods'><li data-type='method'><a href="CollectionLambdas.html#.addClass">addClass</a></li><li data-type='method'><a href="CollectionLambdas.html#.assignAttrValues">assignAttrValues</a></li><li data-type='method'><a href="CollectionLambdas.html#.attr">attr</a></li><li data-type='method'><a href="CollectionLambdas.html#.clear">clear</a></li><li data-type='method'><a href="CollectionLambdas.html#.css">css</a></li><li data-type='method'><a href="CollectionLambdas.html#.empty">empty</a></li><li data-type='method'><a href="CollectionLambdas.html#.remove">remove</a></li><li data-type='method'><a href="CollectionLambdas.html#.removeAttr">removeAttr</a></li><li data-type='method'><a href="CollectionLambdas.html#.removeClass">removeClass</a></li><li data-type='method'><a href="CollectionLambdas.html#.replaceClass">replaceClass</a></li><li data-type='method'><a href="CollectionLambdas.html#.setData">setData</a></li><li data-type='method'><a href="CollectionLambdas.html#.styleInline">styleInline</a></li><li data-type='method'><a href="CollectionLambdas.html#.toggleAttr">toggleAttr</a></li><li data-type='method'><a href="CollectionLambdas.html#.toggleClass">toggleClass</a></li><li data-type='method'><a href="CollectionLambdas.html#.toggleStyleFragments">toggleStyleFragments</a></li><li data-type='method'><a href="CollectionLambdas.html#.visible">visible</a></li></ul></li><li><a href="ExtendedNodelistLambdas.html">ExtendedNodelistLambdas</a><ul class='methods'><li data-type='method'><a href="ExtendedNodelistLambdas.html#.append">append</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.appendTo">appendTo</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.delegate">delegate</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.each">each</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.find">find</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.find$">find$</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.first">first</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.first$">first$</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.getData">getData</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.hasClass">hasClass</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.html">html</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.htmlFor">htmlFor</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.insert">insert</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.is">is</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.isEmpty">isEmpty</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.on">on</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.ON">ON</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.outerHtml">outerHtml</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.prop">prop</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.replace">replace</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.single">single</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.text">text</a></li><li data-type='method'><a href="ExtendedNodelistLambdas.html#.val">val</a></li></ul></li><li><a href="ExtensionHelpers.html">ExtensionHelpers</a><ul class='methods'><li data-type='method'><a href="ExtensionHelpers.html#.getAllDataAttributeValues">getAllDataAttributeValues</a></li><li data-type='method'><a href="ExtensionHelpers.html#.hex2Full">hex2Full</a></li><li data-type='method'><a href="ExtensionHelpers.html#.hex2RGBA">hex2RGBA</a></li><li data-type='method'><a href="ExtensionHelpers.html#.initializePrototype">initializePrototype</a></li><li data-type='method'><a href="ExtensionHelpers.html#.isVisible">isVisible</a></li><li data-type='method'><a href="ExtensionHelpers.html#.loop">loop</a></li></ul></li><li><a href="ExtensionHelpers_HandlerFactory.html">ExtensionHelpers/HandlerFactory</a><ul class='methods'><li data-type='method'><a href="ExtensionHelpers_HandlerFactory.html#.addListenerIfNotExisting">addListenerIfNotExisting</a></li><li data-type='method'><a href="ExtensionHelpers_HandlerFactory.html#.createHandlerForHID">createHandlerForHID</a></li><li data-type='method'><a href="ExtensionHelpers_HandlerFactory.html#.metaHandler">metaHandler</a></li></ul></li><li><a href="JQL.html">JQL</a><ul class='methods'><li data-type='method'><a href="JQL.html#.ExtendedNodeList">ExtendedNodeList</a></li><li data-type='method'><a href="JQL.html#.setStyle">setStyle</a></li><li data-type='method'><a href="JQL.html#.virtual">virtual</a></li></ul></li><li><a href="JQL_DOM.html">JQL/DOM</a><ul class='methods'><li data-type='method'><a href="JQL_DOM.html#.htmlToVirtualElement">htmlToVirtualElement</a></li></ul></li><li><a href="JQL_ExternalStyling.html">JQL/ExternalStyling</a><ul class='methods'><li data-type='method'><a href="JQL_ExternalStyling.html#.changeCssStyleRule">changeCssStyleRule</a></li></ul></li><li><a href="JQL_HTMLHelpers.html">JQL/HTMLHelpers</a><ul class='methods'><li data-type='method'><a href="JQL_HTMLHelpers.html#.setTagPermission">setTagPermission</a></li></ul></li><li><a href="JQL_HTMLHelpers_AllowUnknown.html">JQL/HTMLHelpers/AllowUnknown</a><ul class='methods'><li data-type='method'><a href="JQL_HTMLHelpers_AllowUnknown.html#.off">off</a></li><li data-type='method'><a href="JQL_HTMLHelpers_AllowUnknown.html#.on">on</a></li></ul></li><li><a href="JQL_Log.html">JQL/Log</a><ul class='methods'><li data-type='method'><a href="JQL_Log.html#.log">log</a></li><li data-type='method'><a href="JQL_Log.html#.setStyling4Log">setStyling4Log</a></li></ul></li><li><a href="JQL_Log_debugLog.html">JQL/Log/debugLog</a><ul class='methods'><li data-type='method'><a href="JQL_Log_debugLog.html#.hide">hide</a></li><li data-type='method'><a href="JQL_Log_debugLog.html#.isVisible">isVisible</a></li><li data-type='method'><a href="JQL_Log_debugLog.html#.off">off</a></li><li data-type='method'><a href="JQL_Log_debugLog.html#.on">on</a></li><li data-type='method'><a href="JQL_Log_debugLog.html#.show">show</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">ExtendedNodeListExtensions.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//noinspection JSCheckFunctionSignatures,JSUnresolvedFunction,JSUnusedGlobalSymbols,JSUnresolvedVariable,ES6UnusedImports,JSIncompatibleTypesComparison

//#region ExtendedNodeList lambda's
import {createElementFromHtmlString} from "./DOM.js";
import {loop, handlerFactory, addHandlerId, isVisible} from "./ExtensionHelpers.js";
// only to enable a 'type' for documentation
import {randomStringExtension} from "./Helpers.js";
import setStyle from "./Styling.js";
randomStringExtension();
/**
 * All extendedNodeListCollectionExtensions for ExtendedNodeList where looping may not be
 * possible. See (the source of)
 * &lt;a href="./ExtensionHelpers.html#.initializePrototype">&lt;code>ExtensionHelpers > initializePrototype&lt;/code>&lt;/a>.
 * &lt;br>&lt;b>Note&lt;/b>: Most methods are &lt;i>chainable&lt;/i>.
 * &lt;br>&lt;b>Note&lt;/b>: &lt;code>.style&lt;/code> is a collection method, not in this file but also chainable.
 * @example
 * // presume $ is the alias for ExtendedNodeList
 * // chainability means:
 * $(`&lt;div id="helloworld">`)
 *   .text(`Example: hello ... world`)
 *   .style( {
 *      marginTop: `1rem`,
 *      border: `3px solid green`,
 *      padding: `5px`, fontSize: `1.2em`,
 *      display: `inline-block` } )
 *   .append($(`&lt;span> OK&lt;/span>`))
 *   .find$(`span`)
 *   .style({color: `red`});
 * @namespace ExtendedNodelistLambdas
 */
const ExtendedNodelistLambdas = {
  /**
   * Get or set textContent the first element in the
   * the collection of [extCollection] and return
   * either a string from the joined array of text
   * values from all elements in the collection or
   * ExtendedNodeList instance.
   * overwrites current textContent of the first element,
   * or appends the text to it.
   * &lt;br>&lt;b>Note&lt;/b>: uses textContent, so no html here
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param textValue {string|undefined} the text to inject. No value returns the property value.
   * @param append {boolean} appends textValue if true, otherwise destructive
   * @returns {ExtendedNodeList|string} ExtendedNodeList instance
   * or (if &lt;code>textValue&lt;/code> is empty) the property value.
   */
  text: (extCollection, textValue, append) => {
    const el = extCollection.first();

    if (!el) { return extCollection; }

    if (!textValue) {
      return el.textContent;
    } else if (append) {
      el.textContent += textValue;
    } else {
      el.textContent = textValue;
    }

    return extCollection;
  },

  /**
   * Alias for loop
   * @example
   * $(`#somediv`).each( (el, i) => ...);
   * // where $ = the alias for the ExtendedNodeList constructor
   */
  each: (extCollection, lambda) => loop(extCollection, lambda),

  /**
   * Get the value of a data-attribute for the first element
   * of the ExtendedNodeList instance
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param dataAttribute {string} some attribute, e.q. 'initial'
   * @param valueWhenFalsy {string|number|undefined} value when the attribute does not exist
   * @returns {string|number|undefined}
   */
  getData: (extCollection, dataAttribute, valueWhenFalsy) => {
    const firstElem = extCollection.first();
    return firstElem &amp;&amp; firstElem.dataset[dataAttribute] || valueWhenFalsy;
  },

  /**
   * Is the collection of the current (implicit) ExtendedNodeList instance empty?
   * @param extCollection {ExtendedNodeList} current ExtendedNodeList
   * @returns {boolean}
   */
  isEmpty: extCollection => extCollection.collection.length &lt; 1,

  /**
   * Checks the values of pseudo selectors :hidden, :visible or :disabled
   * &lt;br>&lt;b>Todo&lt;/b>: really useful?
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param checkValue {string} one of :visibile, :hidden, :disabled
   * @returns {string|boolean}
   */
  is: (extCollection, checkValue) => {
    const firstElem = extCollection.first();

    if (!firstElem) { return true; }

    switch(checkValue) {
      case ":visible": {
        return isVisible(firstElem); // TODO
      }
      case ":hidden": return !isVisible(firstElem);
      case ":disabled": return firstElem.getAttribute("readonly") || firstElem.getAttribute("disabled");
      default: return true;
    }
  },

  /**
   * Checks if (one of) [classNames] exist in the first element of the
   * ExtendedNodeList instance
   * @param extCollection {ExtendedNodeList} (implicit) current ExentedNodeList instance
   * @param classNames {...string}
   * @returns {boolean} true if one of classNames exists in the elements' classList
   */
  hasClass: (extCollection, ...classNames) => {
    const firstElem = extCollection.first();
    return classNames.find( name => firstElem.classList.contains(name)) || false;
  },

  /**
   * Replace a child in the collection of an ExtendedNodeList instance
   * with something else
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param oldChild {HTMLElement} ExtendedNodeList instance or css selector string
   * @param newChild {HTMLElement} or ExtendedNodeList instance
   * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
   */
  replace: (extCollection, oldChild, newChild) => {
    const firstElem = extCollection.first();

    if (newChild.constructor === extCollection.constructor) {
      newChild = newChild.first();
    }

    if (firstElem &amp;&amp; oldChild) {
      oldChild = oldChild.constructor === String
        ? firstElem.querySelector(oldChild)
        : oldChild.constructor === extCollection.constructor
          ? oldChild.first()
          : oldChild;

      if (oldChild &amp;&amp; newChild) {
        oldChild.replaceWith(newChild);
      }
    }

    return extCollection;
  },

  /**
   * Get or set the value of (the first element of)
   * the ExtendedNodeList instance, where the first
   * element is one of input or select HTMLElement
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param value2Set {string|undefined} string or nothing
   * @returns {string|undefined}
   */
  val: (extCollection, value2Set) => {
    const firstElem = extCollection.first();
    if (!firstElem) { return; }
    if ([HTMLInputElement, HTMLSelectElement].includes(firstElem.constructor)) {
      if (value2Set || typeof value2Set === "string") {
        firstElem.value = value2Set;
      }
      return firstElem.value;
    }
  },

  /**
   * Appends one ore more elements to the first element
   * of the instance collection (for real, in the DOM tree)
   * @param extCollection {...ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param elems2Append {...(HTMLElement|ExtendedNodeList|string)}
   * The element(s) to append. If string(s), should be valid html
   * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
   */
  append: (extCollection, ...elems2Append) => {
    const firstElem = extCollection.first();
    if (firstElem &amp;&amp; elems2Append) {
      elems2Append.forEach( elem => {
        if (elem.constructor === String) {
          new extCollection.constructor(elem, firstElem);
        }
        if (elem.collection &amp;&amp; elem.collection.length) {
          elem.collection.forEach(el => firstElem.appendChild(el))
        }
        if (elem instanceof HTMLElement) {
          firstElem.appendChild(elem);
        }
      });
    }
    return extCollection;
  },

  /**
   * Appends the collection of one ExtendedNodeList instance
   * to another instance, so injects the element(s) of
   * [extCollection] to the first element of [extCollection2AppendTo]
   * (for real, injected and visible in the DOM tree)
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param extCollection2AppendTo {ExtendedNodeList} the instance to append to
   * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
   */
  appendTo: (extCollection, extCollection2AppendTo) => {
    if ( extCollection2AppendTo.constructor !== extCollection.constructor ) {
      extCollection2AppendTo = new extCollection.constructor(extCollection2AppendTo);
    }

    extCollection2AppendTo.append(extCollection);

    return extCollection2AppendTo;
  },

  /**
   * Injects an element before the first element
   * of the collection of an instance of ExtendedNodeList
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param elem {HTMLElement|ExtendedNodeList} the element to append
   * @param insertBeforeElem {string|HTMLElement|undefined} optional: string or first element of extCollection
   * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
   */
  insert: (extCollection, elem, insertBeforeElem) => {
    const firstElem = extCollection.first();
    if (!firstElem) { return extCollection; }

    if (insertBeforeElem) {
      // noinspection JSIncompatibleTypesComparison
      insertBeforeElem = insertBeforeElem.constructor === String
        ? firstElem.querySelector(insertBeforeElem)
        : insertBeforeElem.constructor === extCollection.constructor
          ? insertBeforeElem.first()
          : insertBeforeElem;
    } else {
      insertBeforeElem = firstElem.childNodes[0];
    }

    // noinspection JSIncompatibleTypesComparison
    if ( elem.constructor === extCollection.constructor ) {
      elem = elem.first();
    }

    firstElem.insertBefore(elem, insertBeforeElem);

    return extCollection;
  },

  /**
   * Retrieves a single element from an instance of ExtendedNodeList
   * and returns a new ExtendedNodeList instance from that element
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param indexOrSelector {number|string}the index of the instance collection
   * @returns {ExtendedNodeList} instance of ExtendedNodeList, so chainable
   */
  single: (extCollection, indexOrSelector = "0") => {
    if (extCollection.collection.length > 0) {
      if (isNaN(+indexOrSelector) &amp;&amp; extCollection.find(indexOrSelector)) {
        return extCollection.find$(indexOrSelector);
      }
      const index = +indexOrSelector;
      return index &lt; extCollection.collection.length
        ? new extCollection.constructor(extCollection.collection[indexOrSelector])
        : extCollection;
    } else {
      return extCollection;
    }
  },

  /**
   * Retrieve the first element of the ExtendedNodeList instance collection
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param asExtCollection {boolean} if true, return new ExtendedNodeList instance, else HTMLElement
   * true => return as new ExtendedNodeList instance, false: as raw HTMLElement
   * @returns {ExtendedNodeList|HTMLElement|undefined} ExtendedNodeList instance, HTMLElement or nothing
   */
  first: (extCollection, asExtCollection = false) => {
    if (extCollection.collection.length > 0) {
      return asExtCollection
        ? extCollection.single()
        : extCollection.collection[0];
    }
    return undefined;
  },

  /**
   * Retrieve first [el] from the collection of the ExtendedNodeList instance
   * and return it as a new ExtendedNodeList instance
   * (if it exists, otherwise undefined)
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param indexOrSelector {number} the collection index
   * @returns {ExtendedNodeList|undefined} ExtendedNodeList instance or nothing
   */
  first$: (extCollection, indexOrSelector) => extCollection.single(indexOrSelector),

  /**
   * Find one or more elements within the ExtendedNodeList instance collection
   * using a css query (e.g. '.someClass')
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param selector {string} css selector
   * @returns {Array|NodeListOf}
   */
  find: (extCollection, selector) => {
    const firstElem = extCollection.first();
    return firstElem &amp;&amp; firstElem.querySelectorAll(selector) || [];
  },

  /**
   * Find one or more elements within the ExtendedNodeList instance collection
   * using a css query (e.g. '.someClass') and return a new ExtendedNodeList instance
   * from it's result
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param selector {string} css selector
   * @returns {ExtendedNodeList|undefined} a new ExtendedNodeList instance or nothing
   */
  find$: (extCollection, selector) => {
    const firstElem = extCollection.first();
    return firstElem &amp;&amp; selector &amp;&amp; new extCollection.constructor(firstElem.querySelector(selector));
  },

  /**
   * Get or set a property/attribute value of first element from
   * the ExtendedNodeList instance collection
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param property {string} (e.g. 'title')
   * @param value {string|undefined} If it has a value, then set the property value
   * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
   */
  prop: (extCollection, property, value) => {
    const firstElem = extCollection.first();
    if (firstElem &amp;&amp; property in firstElem) {
      firstElem[property] = value || firstElem[property];
      return value ? extCollection : firstElem[property];
    }

    return extCollection;
  },

  /**
   * Add handler lambda for an ExtendedNodeList instance.
   * &lt;br>A handler id is created if applicable (addHandlerId)
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param type {string} event type (e.g. 'click')
   * @param callback {function} handler lambda
   * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
   */
  on: (extCollection, type, callback) => {
    if (extCollection.collection.length) {
      const cssSelector = addHandlerId(extCollection);
      handlerFactory(extCollection, type, cssSelector, callback);
    }

    return extCollection;
  },

  /**
   * Get or set (inner-) html of the first element in the
   * collection of [extCollection] and return
   * either a string from the joined array of text
   * values from all elements in the collection or
   * ExtendedNodeList instance.
   * overwrites current html of the first element,
   * or appends the value to it.
   * Note: the html is always sanitized (see DOMCleanup)
   * @todo split up (get, set)
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param htmlValue {string|undefined} string or nothing
   * @param append {boolean} appends the html if true, otherwise destructive
   * @returns {string|ExtendedNodeList} current ExtendedNodeList instance or
   * (if &lt;code>htmlValue&lt;/code> is empty) the current (inner)html of the first
   * element.
   */
  html: (extCollection, htmlValue, append) => {
    if (htmlValue === undefined) {
      const firstEl = extCollection.first();
      if (firstEl) {
        return firstEl.innerHTML;
      }
      return "";
    }

    if (extCollection.collection.length) {
      const el2Change = extCollection.first();
      if (!el2Change) { return ""; }
      if (`{htmlValue}`.trim().length &lt; 1) {
        el2Change.textContent = "";
      } else {
        const nwElement = createElementFromHtmlString(`&lt;div>${htmlValue}&lt;/div>`);

        if (append) {
          el2Change.innerHTML += nwElement.innerHTML;
        } else {
          el2Change.innerHTML = nwElement.innerHTML;
        }
      }
    }

    return extCollection;
  },

  /**
   * Retrieves outer html for the first element of the ExtendedNodeList instance
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @returns {string|undefined}
   */
  outerHtml: extCollection => (extCollection.first() || {outerHTML: undefined}).outerHTML,

  /**
   * Sets/adds/removes html for an element within the collection
   * of the ExtendedNodeList instance (identified with a css query).
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param forQuery {string} a css query (e.g. `#someId`)
   * @param htmlString {string} the html string to replace or append to exististing.
   * &lt;br>&lt;b>Note&lt;/b>: if the string is empty, the html is removed
   * &lt;br>&lt;b>Note&lt;/b>: the html is always sanitized (see DOMCleanup)
   * @param append {boolean} if true html will be appended, otherwise destructive
   * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
   */
  htmlFor: (extCollection, forQuery, htmlString = "", append = false) => {
    if (forQuery &amp;&amp; extCollection.collection.length) {
      const el2Change = extCollection.find$(forQuery);
      if (!el2Change) {
        return extCollection;
      }

      if (`{htmlValue}`.trim().length &lt; 1) {
        el2Change.textContent = "";
        return extCollection;
      }

      const nwElement = createElementFromHtmlString(`&lt;div>${htmlString}&lt;/div>`);
      nwElement &amp;&amp; el2Change.html(nwElement.innerHTML, append);
    }
    return extCollection;
  },

  /**
   * Create event handler lambda(s)
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * &lt;br>&lt;b>Note&lt;/b>: may be empty
   * @param type {string} event type (e.g. 'click')
   * @param cssSelector {string} e.g. '#someId'
   * @param callbacks {...function} one or more lambda functions
   * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
   */
  delegate: (extCollection, type, cssSelector, ...callbacks) => {
    callbacks.forEach( callback =>
      handlerFactory(extCollection, type, cssSelector, callback) );

    return extCollection;
  },

  /**
   * Add handler lambda(s) for event [type] and
   * the ExtendedNodeList instance
   * @param extCollection {ExtendedNodeList} (implicit) current ExtendedNodeList instance
   * @param type {string} event type (e.g. 'click')
   * @param callbacks {...functions} one or more lambda functions
   * @returns {ExtendedNodeList} ExtendedNodeList instance, so chainable
   */
  ON: (extCollection, type, ...callbacks) => {
    if (extCollection.collection.length) {
      callbacks.forEach(cb => extCollection.on(type, cb));
    }

    return extCollection;
  },
};

export default ExtendedNodelistLambdas;

//#endregion ExtendedNodeList lambda's</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Wed Sep 29 2021 11:37:07 GMT+0200 (Midden-Europese zomertijd) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
